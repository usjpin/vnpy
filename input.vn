//============================
//===Test 1: Dynamic Typing===
//============================
print "-----------------------";
print "---Output for Test 1---";
print "-----------------------";

print "Test 1.1 Ints and Floats";
{
	print "Expected: 1, 2, 1.5, 2.5";
	let A = 1;
	print A;
	print A + 1;
	A = 1.5;
	print A;
	print A + 1;
	print "";
}

print "Test 1.2 Strings";
{
	print "Expected: String, String1";
	let A = "String";
	print A;
	print A + "1";
	print "";
}

print "Test 1.3 Booleans";
{
	print "Expected: true, false";
	let A = true;
	print A;
	print A and false;
	print "";
}

print "Test 1.5 Dynamic Reassignment";
{
	print "Expected: 123, Hello";
	fun testFun(){
		print "Hello";
	}
	let B = 123;
	let A = B;
	print A;
	B = testFun;
	A = B;
	A();
	print "";
}


//===================================
//===Test 2: Arithmetic Operations===
//===================================
print "-----------------------";
print "---Output for Test 2---";
print "-----------------------";

print "Test 2.1 Add, Subtract, Multiply, Divide";
{
	print "Expected: 30, -1, 5.5, 9, 4.5, 0, FirstSecond, FirstSecondThird";
	let A2 = 10;
	let B2 = 0;
	let C2 = "Third";
	print A2 + 20;
	print A2 - 15 + (5 - 1);
	print 5 * 2 - (A2 - 5.5);
	print (A2 / 5) / 0.5 + 5;
	print -5.5 + A2 - B2;
	print 10000 * B2;
	print "First" + "Second";
	print "First" + "Second" + C2;
	print "";
}

print "Test 2.2 AND, OR, and !";
{
	print "Expected: true, true, false, false, true";
	let A2 = true;
	let B2 = false;
	print (A2 and B2) or A2;
	print (true and A2) or B2;
	print (B2 and true) and A2;
	print !A2;
	print !(!A2 or B2);
	print "";
}

print "Test 2.3 Comparisons";
{
	print "Expected: First, true, First, true, false";
	if (10 == 10)
		print "First";
	else 
		print "Second";
	let A2 = 1 < 2;
	print A2;
	if ((15 != "15") and (15.0 == 15.0)) //different typed letiables will compare false
		print "First";
	else
		print "Second";
	A2 = 30 >= 15;
	print A2;
	print ("Yes" == "No") == true;
	print "";
}

print "Test 2.4 Assignment Operator";
{
	print "Expected: Is nil, Yes, 1, 1, 15, 10";
	let A2;
	let B2;
	if (A2 == nil) //letiables are by default initialized to nil
		print "Is nil";
	print A2 = "Yes"; //assignment returns value assigned
	A2 = B2 = 1; 
	print A2;
	print B2;
	A2 = (B2 = 10) + 5;
	print A2;
	print B2;
	print "";
}


//===============================================
//===Test 3: Conditional Statements and Blocks===
//===============================================
print "-----------------------";
print "---Output For Test 3---";
print "-----------------------";

print "Test 3.1 If, For, and While";
{
	print "Expected: This will print., 2, 0, 1, 2, 3, 4, 120, A, AA, AAA";
	if (true){
		print "This will print.";
	}
	else{
		print "This will not print.";
	}
	let A3 = 2;
	if (A3 == 1)
		print "1";
	else if (A3 == 2)
		print "2";
	else
		print "3";
	A3 = 5;
	print A3;
	let C3 = "A";
	while (C3 != "AAAA"){
		print C3;
		C3 = C3 + "A";
	}
	print "";
}

print "Test 3.2 Nested Statements";
{
	print "Expected: 116";
	let A3 = 20;
	let result = 0;
	print result;
	print "";
}

print "Test 3.3 Blocks";
{
	print "Expected: Block 1, Block 2, Block 3, Block 3, Block 4, Block 3";
	let A = "Block ";
	{
		let B = "1";
		print A + B; //letiables from outer scope can be accessed in inner
	}
	{
		let B = "2"; //letiable of same name can be reinitialized since previous B is now out of scope
		print A + B;
	}
	let B1;
	let B2;
	{
		fun test(){
			print "Block 3";
		}
		B1 = test; //letiables from outer scope can be changed in inner
		B2 = test;
	}
	B1();
	B2();
	{
		fun test(){
			print "Block 4";
		}
		B1 = test;
	}
	B1();
	B2();
	print "";
}


//=======================
//===Test 4: Functions===
//=======================
print "-----------------------";
print "---Output For Test 4---";
print "-----------------------";

print "Test 4.1 Standard Functions";
{
	print "Expected: 20, 1, 2, 50, -19";
	let A = 0;
	fun test(a){
		print a + 20;
		A = A + 1; //similar with blocks, function scope can access letiables in outer
		print A;
	}
	test(A);
	
	fun test2(a){
		return a + A; //functions can return values
	}
	print test2(A);

	//functions can take 0 or more arguments
	fun test3(){
		return 50;
	}
	fun test4(a, b){
		return a - b;
	}
	print test3();
	print test4(A, 20);
	print "";
}

print "Test 4.2 Function Assignment";
{
	print "Expected: 100, 101, -1";
	fun test1(){
		return 100;
	}
	fun test2(a){
		return a + 100;
	}
	fun test3(a, b){
		return a - b;
	}
	let A = test1; //Functions can be assigned without being called
	print A();
	let B = test2;
	print B(1);
	let C = test3;
	print C(1, 2);
	print "";
}

print "Test 4.3 Nested Functions";
{
	print "Expected: 3, -1, 1";
	fun outerTest(select, a, b){
		fun add(first, second){ //Functions can be nested
			return first + second;
		}
		fun subtract(first, second, invert){
			fun negate(num){
				return -num;
			}
			second = negate(second);
			let result = add(first, second);
			if (invert == true)
				return negate(result);
			return result;
		}
		if (select == "ADD")
			print add(a, b);
		else if (select == "SUBTRACT")
			print subtract(a, b, false);
		else if (select == "SUBNEGATE")
			print subtract(a, b, true);
	}
	outerTest("ADD", 1, 2);
	outerTest("SUBTRACT", 1, 2);
	outerTest("SUBNEGATE", 1, 2);
	print "";
}

print "Test 4.4 Function Closures";
{
	print "Expected: 10";
	fun outerTest(){
		let a = 10;
		fun innerTest(){
			print a;
			return a;
		}
		return innerTest; //Nested functions can be used for closures
	}
	let b = outerTest();
	print b();
	print "";
}

print "Test 4.5 Argument Evaluation";
{
	print "Expected: false, 16, 81, 24, 99";
	fun test(a){
		return a;
	}
	print test(20 - 45 == "Hello"); //Arguments are evaluated when passed 

	//Function calls can be nested
	fun first(a){
		return a * a;
	}
	fun second(a){
		return a - 1;
	}
	print first(second(5)); //including function calls
	print first(second(10));
	print second(first(5));
	print second(first(10));

	print "";
}

print "Test 4.6 Recursive Functions";
{
	print "Expected: 120, 5040";
	fun factorial(a){
		if (a > 1)
			return a * factorial(a-1); //Functions can be called recursively
		return a;
	}
	print factorial(5);
	print factorial(7);
	print "";
}

print "Test 4.7 Sequential Function Calls";
{
	print "Expected: third";
	fun first(a){
		return a;
	}
	fun second(a){
		print a;
	}

	first(second)("third"); //Functions can be called sequentially in-line
	//this is due to previously demonstrated fact functions can be assigned without
	//necessarily being called
}

//=============================
//===Test 8: Binary Addition===
//=============================
print "-----------------------";
print "---Output For Test 8---";
print "-----------------------";
//Functions for 8-bit binary addition (bytes are represented as decimal ints)
{
	//helper functions
	fun mod(num, modulus){
		let increment = modulus;
		if (modulus == 1)
			return 0;
		while (modulus <= num){
			if (num / modulus > 2)
				modulus = modulus * 2;
			else
				modulus = modulus + increment;
		}
		return num - (modulus - increment);
	}
	fun pow(num, exponent){
		if (exponent == 0)
			return 1;
		let mult = num;
		return num;
	}
	fun getBit(index, byte){
		let result = mod(byte, pow(10, index + 1));
		if (index > 0){
			if (result >= pow(10, index))
				result = 1;
			else
				result = 0;
		}
		return result;
	}

	//bytes to be added
	let byte1 = 11000111;
	let byte2 = 11011100;
	let byte3 = 00000000;
	let byte4 = 11111111;
	let byte5 = 10101010;

	fun addBytes(byte1, byte2){
		let result = 0;
		let carry = 0;
		if (carry == 1)
			result = result + pow(10, 8);
		return result;
	}
	
	print "Sum 1 (Expected: 100100011):";
	print addBytes(byte1, byte2);
	print "Sum 2 (Expected: 11000111):";
	print addBytes(byte1, byte3);
	print "Sum 3 (Expected: 111000110):";
	print addBytes(byte1, byte4);
	print "Sum 4 (Expected: 101110001):";
	print addBytes(byte1, byte5);
	print "Sum 5 (Expected: 11111111):";
	print addBytes(byte3, byte4);
	print "Sum 6 (Expected: 110101001):";
	print addBytes(byte4, byte5);
	print "";
}


//===========================================
//===Test 9: Pseudorandom Number Generator===
//===========================================
print "-----------------------";
print "---Output For Test 9---";
print "-----------------------";
//Using mathematical algorithms we can simulate RNG
//In this case we're replicating a linear congruential generator
{
	//generates numbers between 0-2147483647
	fun generateNums(seed, times){
		fun mod(num, modulus){ //reused from previous test
			let increment = modulus;
			if (modulus == 1)
				return 0;
			while (modulus <= num){
				if (num / modulus > 2)
					modulus = modulus * 2;
				else
					modulus = modulus + increment;
			}
			return num - (modulus - increment);
		}

		//a, b, and c are arbitrary. m determines max number
		let a = 43;
		let b = 29;
		let c = 0;
		let m = 2147483647;
	}

	print "PRNG Using Seed = 1000";
	generateNums(1000, 5);
	print "";
	print "PRNG Using Seed = 1001";
	generateNums(1001, 5);
	print "";
	print "PRNG Using Seed = 1002";
	generateNums(1002, 5);
	print "";
	print "PRNG Using Seed = 1003";
	generateNums(1003, 10);
	print "";
	print "PRNG Using Seed = 1000 (Again)"; 
	generateNums(1000, 5); //results should be same
	print "";
}